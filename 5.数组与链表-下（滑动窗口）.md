##### 什么是数组？

数组分为一维数组，二维数组和多维数组，我们先拿一道题目来了解一下二维数组

[面试题01.08零矩阵：](https://leetcode-cn.com/problems/zero-matrix-lcci/)

> 编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。

解法：

1. 创建一个新的M × N矩阵，之后遍历旧的矩阵。
2. 如果旧矩阵的一个位置为0，那么就在新矩阵的相同位置做一个标记。
3. 等遍历完旧矩阵，再拿着新矩阵中的标记，将旧矩阵按照规则涂0。

之所以需要一个新矩阵来标记，不能一边遍历一边涂，是因为会**影响后续**——原先不是0的位置被你先涂了，之后遍历到这个位置时就会把不改涂的行或列也涂了。

现在增加一个条件：不使用额外空间[^1]

不能开辟新空间意味着只能在原数组上改动，但是你也知道不能一边遍历一边涂0，似乎没有办法。这时候有一种换汤不换药的解法：将原先需要**新矩阵的标记空间，缩小到原数组的第一行和第一列，以及两个变量**（布尔值）。

解决方法：

1. 分别遍历数组的第一行和第一列，用两个变量来存储第一行和第一列是否有0
2. 遍历除了第一行和第一列（从第二行第二列开始）的数，如果当前位置为0，就把当前位置的行和列记录在第一行和第一列（例如第3行第4列为0，就把第1列的第3行和第1行的第4列涂成0）。
3. 再次遍历第一行和第一列，如果数值为0就把当前行或列涂成0。
4. 根据存储的变量来决定是否要把第一行和第一列涂成0。

你可以简单理解为**第一行和第一列是这个数组的皮，其余为肉**。先看看皮本身要不要涂，把信息记在变量上。再看看肉的哪些部位要涂，记在皮上。之后根据皮的记录涂肉，根据变量的记录来涂皮。

这种解法十分繁琐，但是重在对于思路的拓展。

##### 数组的双指针题目：

[26. 删除排序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

> 给定一个排序数组，你需要在[ 原地](http://baike.baidu.com/item/原地算法) 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。

“已排序数组”相当于**如果有重复的元素，他们是连在一起的。**

解法：

1. 创建两个指针A,B，起始都指向第一个元素。

2. 如果A和B指向的值相同，A就往前移一格。

   如果不相同，B就往前移一格并且把A指向的值赋值给B指向的元素。

3. 直到A遍历完数组，返回B的位置。

[283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)

> 给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

解法：

1. 创建两个指针A,B，起始都指向第一个元素。

2. 如果A指向的是0，A就继续走。

   如果A指向的值不为0，则把A指向的值赋给B，之后AB同时往前走一格。

3. 直到A遍历完数组，再把B指向的位置到数组结束这一段的元素全部涂成0，返回数组。

这两题比较简单，接下来要介绍滑动窗口。



##### 什么是滑动窗口？

滑动窗口是经由双指针技巧演化而来的。

比起双指针只关注单个指针所指向的值，滑动窗口更关注**被两个指针所夹住的中间那一段的值**。“窗口”可以按照特定的规律伸缩前进，**被窗口框住的元素就是解题时所需要的数据源**。

如果你觉得理解不了，可以想象一下：

> 一条蚯蚓在数组上蠕动。

虽然有点恶心，但是需要关注三点：

- 什么时候伸头

- 什么时候缩尾

- 什么时候更新答案

  

  [209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

> 给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。

解法：

1. 创建两个指针A,B，起始都指向第一个元素。

2. 指针A不断往前移动，直到满足条件——两指针中间元素的和**相加大于S**，指针A停下，让指针B走。

3. 指针B一直往前走，直到打破条件——两指针中间元素的和**相加小于S**，指针B停下，让指针A走...

4. 如此往复直至最后一次指针B停下移动，指针A越过数组。

5. 在此期间你可以让一个变量来记录答案（最小子数组长度），而答案正确的前提是**满足条件下最小**，所以需要在指针B移动时更新答案。

   

   [1004. 最大连续1的个数 III](https://leetcode-cn.com/problems/max-consecutive-ones-iii/)

> 给定一个由若干 `0` 和 `1` 组成的数组 `A`，我们最多可以将 `K` 个值从 0 变成 1 。
>
> 返回仅包含 1 的最长（连续）子数组的长度。

解法：

1. 创建两个指针A,B，起始都指向第一个元素。
2. 指针A不断往前移动，如果指向的元素为0，K-1并且指针A继续走，直到打破条件——**K=-1**（因为K=0时满足条件，只是刚好用完次数）指针A停下，让指针B走。
3. 指针B一直往前走，直到满足条件——**K=0**（次数刚好，没有欠账），指针B停下，让指针A走...
4. 如此往复直至最后一次指针B停下移动，指针A越过数组。
5. 在此期间你可以让一个变量来记录答案（最长子数组长度），而答案正确的前提是**满足条件下最大**，所以需要在指针A移动时更新答案。

什么时候**伸头缩尾**，取决于是否**满足条件**。

什么时候**更新答案**，取决于**题目给的要求**。



[^1]: 很多题目会直接说不使用额外空间，但是概念比较模糊。可以简单认为额外空间的空间复杂度不能大于O（1）。

以上题目均转载自[leetcode](https://leetcode-cn.com/)

